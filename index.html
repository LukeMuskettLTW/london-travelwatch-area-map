<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>London TravelWatch Area Map</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .panel {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1000;
      width: 360px;
      max-width: calc(100vw - 24px);
      background: rgba(255,255,255,0.97);
      border-radius: 12px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.16);
      padding: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Header row with chevron */
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .panel h3 { margin: 0; font-size: 18px; line-height: 1.2; }

    .chevron-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.9);
      cursor: pointer;
      user-select: none;
    }
    .chevron-btn:focus {
      outline: 2px solid rgba(0,0,0,0.25);
      outline-offset: 2px;
    }
    .chevron {
      width: 16px;
      height: 16px;
      display: inline-block;
      transition: transform 180ms ease;
      transform-origin: 50% 50%;
    }
    /* Rotated when expanded */
    .chevron-btn[aria-expanded="true"] .chevron {
      transform: rotate(180deg);
    }

    .row { display: flex; gap: 10px; align-items: center; }
    .row + .row { margin-top: 8px; }
    label { display: flex; align-items: center; gap: 10px; font-size: 15px; }
    input[type="checkbox"] { transform: scale(1.1); }

    .section { margin-top: 14px; border-top: 1px solid rgba(0,0,0,0.08); padding-top: 12px; }

    .search label { font-weight: 700; margin-bottom: 8px; display: block; font-size: 16px; }
    .search .row { align-items: stretch; }
    .search input[type="text"]{
      flex: 1;
      padding: 10px 12px;
      border: 1px solid rgba(0,0,0,0.22);
      border-radius: 10px;
      font-size: 15px;
      outline: none;
    }
    .btn {
      padding: 10px 12px;
      border: 0;
      border-radius: 10px;
      font-size: 15px;
      cursor: pointer;
      background: #2b2b2b;
      color: #fff;
      white-space: nowrap;
    }
    .hint { margin-top: 8px; font-size: 12px; color: rgba(0,0,0,0.68); line-height: 1.35; }

    /* Collapsible toggles wrapper */
    .toggles-wrap {
      overflow: hidden;
      transition: max-height 220ms ease, opacity 160ms ease;
      opacity: 1;
      max-height: 500px; /* plenty when expanded */
    }
    .toggles-wrap.collapsed {
      opacity: 0;
      max-height: 0;
      pointer-events: none;
      margin: 0;
      padding: 0;
    }

    /* Separate floating key (bottom-right) */
    .map-key {
      background: rgba(255,255,255,0.95);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.16);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 13px;
      line-height: 1.25;
    }
    .map-key .title {
      font-weight: 700;
      margin: 0 0 8px 0;
      font-size: 13px;
    }
    .map-key .legend {
      display: grid;
      grid-template-columns: 14px 1fr;
      gap: 8px 10px;
      align-items: center;
    }
    .map-key .swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.25);
    }

    /* Slightly tighten on small screens */
    @media (max-width: 520px) {
      .panel { width: 320px; }
      label { font-size: 14px; }
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel" id="panel">
    <div class="panel-header">
      <h3>London TravelWatch Area Map</h3>

      <!-- Chevron button toggles ONLY the checkbox list -->
      <button id="btnChevron" class="chevron-btn" type="button" aria-expanded="true" aria-controls="togglesWrap" title="Show/hide layers">
        <!-- simple chevron (down) -->
        <svg class="chevron" viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 9l6 6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        </svg>
      </button>
    </div>

    <!-- Toggles: LTW first (area then stations), then TF (area then stations) -->
    <!-- Stations OFF by default -->
    <div id="togglesWrap" class="toggles-wrap">
      <div class="row">
        <label><input id="chkLtwArea" type="checkbox" checked> London TravelWatch area</label>
      </div>
      <div class="row">
        <label><input id="chkLtwStations" type="checkbox"> London TravelWatch stations</label>
      </div>
      <div class="row">
        <label><input id="chkTfArea" type="checkbox"> Transport Focus area</label>
      </div>
      <div class="row">
        <label><input id="chkTfStations" type="checkbox"> Transport Focus stations</label>
      </div>
    </div>

    <!-- Search stays visible even when toggles are collapsed -->
    <div class="section search">
      <label for="txtSearch">Search station…</label>
      <div class="row">
        <input id="txtSearch" type="text" placeholder="e.g. Orpington" />
        <button id="btnSearch" class="btn" type="button">Go</button>
      </div>
      <div class="hint">
        Searches station name (case-insensitive), zooms, and opens the popup.
      </div>
    </div>
  </div>

  <script>
    // Files (kept internal; not shown in UI)
    const CSV_FILE = "correct_ltw_list.csv";
    const BOUNDARY_FILE = "ltw_remit_boundary.geojson";

    const REMIT_LTW = "London TravelWatch";
    const REMIT_TF  = "Transport Focus";

    // Resolve URLs safely for localhost, GitHub Pages subpaths, and future website hosting
    const csvUrl = new URL(CSV_FILE, window.location.href).toString();
    const boundaryUrl = new URL(BOUNDARY_FILE, window.location.href).toString();

    const toBool = (v) => String(v).trim().toLowerCase() === "true" || v === true;
    const keyify = (s) => String(s || "").trim().toLowerCase();

    // Map
    const map = L.map("map", { preferCanvas: true }).setView([51.5074, -0.1278], 9);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Floating Key (bottom-right) — light green, dark green, light red, dark red
    const keyControl = L.control({ position: "bottomright" });
    keyControl.onAdd = function () {
      const div = L.DomUtil.create("div", "map-key");
      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);

      div.innerHTML = `
        <div class="title">Key</div>
        <div class="legend">
          <div class="swatch" style="background:#0b7a3b; opacity:0.22;"></div>
          <div>London TravelWatch area</div>

          <div class="swatch" style="background:#0b7a3b;"></div>
          <div>London TravelWatch station</div>

          <div class="swatch" style="background:#b2182b; opacity:0.10;"></div>
          <div>Transport Focus area</div>

          <div class="swatch" style="background:#b2182b;"></div>
          <div>Transport Focus station</div>
        </div>
      `;
      return div;
    };
    keyControl.addTo(map);

    // Layers (stations OFF by default)
    const ltwStationsLayer = L.layerGroup();
    const tfStationsLayer  = L.layerGroup();
    let ltwAreaLayer = null;
    let tfAreaLayer  = null;

    // Grouped station index by name+remit (so Rail + Tube at same named station becomes 1 dot)
    const stationGroups = new Map(); // key -> group
    const allGroupMarkers = []; // for search: {nameKey, name, marker, lat, lon, remit}

    function circleStyle(remit) {
      return remit === REMIT_LTW
        ? { radius: 4, weight: 1, opacity: 1.0, fillOpacity: 0.85 }
        : { radius: 4, weight: 1, opacity: 0.9, fillOpacity: 0.65 };
    }

    function circleColors(remit) {
      return remit === REMIT_LTW
        ? { color: "#0b7a3b", fillColor: "#0b7a3b" }
        : { color: "#b2182b", fillColor: "#b2182b" };
    }

    function applyLayerToggles() {
      const showLtwArea     = document.getElementById("chkLtwArea").checked;
      const showLtwStations = document.getElementById("chkLtwStations").checked;
      const showTfArea      = document.getElementById("chkTfArea").checked;
      const showTfStations  = document.getElementById("chkTfStations").checked;

      if (ltwAreaLayer) { if (showLtwArea) map.addLayer(ltwAreaLayer); else map.removeLayer(ltwAreaLayer); }
      if (tfAreaLayer)  { if (showTfArea)  map.addLayer(tfAreaLayer);  else map.removeLayer(tfAreaLayer); }

      if (showLtwStations) map.addLayer(ltwStationsLayer); else map.removeLayer(ltwStationsLayer);
      if (showTfStations)  map.addLayer(tfStationsLayer);  else map.removeLayer(tfStationsLayer);
    }

    function meanLatLon(points) {
      let sumLat = 0, sumLon = 0;
      for (const p of points) { sumLat += p.lat; sumLon += p.lon; }
      return { lat: sumLat / points.length, lon: sumLon / points.length };
    }

    function updateGroupMarker(group) {
      const { lat, lon } = meanLatLon(group.points);
      group.lat = lat; group.lon = lon;

      const modes = Array.from(group.modes).sort((a,b)=>a.localeCompare(b));
      const modesText = modes.length ? modes.join(", ") : "—";

      const popupHtml = `
        <b style="font-size:16px">${group.name}</b><br>
        Remit: ${group.remit}<br>
        Modes: ${modesText}
      `;

      if (!group.marker) {
        group.marker = L.circleMarker([lat, lon], {
          ...circleStyle(group.remit),
          ...circleColors(group.remit)
        }).bindPopup(popupHtml);

        // Add to correct layer
        if (group.remit === REMIT_LTW) group.marker.addTo(ltwStationsLayer);
        else group.marker.addTo(tfStationsLayer);

        allGroupMarkers.push({
          nameKey: keyify(group.name),
          name: group.name,
          marker: group.marker,
          lat,
          lon,
          remit: group.remit
        });
      } else {
        group.marker.setLatLng([lat, lon]);
        group.marker.setPopupContent(popupHtml);
      }
    }

    async function loadStationsFromCSV() {
      return new Promise((resolve, reject) => {
        Papa.parse(csvUrl, {
          download: true,
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              if (results.errors && results.errors.length) {
                console.warn("PapaParse errors:", results.errors);
              }

              const rows = results.data || [];
              let bad = 0;

              for (const r of rows) {
                const lat = r.latitude;
                const lon = r.longitude;

                if (typeof lat !== "number" || typeof lon !== "number" || !isFinite(lat) || !isFinite(lon)) {
                  bad++;
                  continue;
                }

                const remit = toBool(r.in_ltw_area) ? REMIT_LTW : REMIT_TF;
                const name = (r.name || "(no name)").trim();
                const mode = String(r.mode || "").trim();

                // Group key = station name + remit
                const gKey = `${keyify(name)}||${remit}`;
                let group = stationGroups.get(gKey);
                if (!group) {
                  group = { key: gKey, name, remit, points: [], modes: new Set(), marker: null, lat: null, lon: null };
                  stationGroups.set(gKey, group);
                }

                group.points.push({ lat, lon });
                if (mode) group.modes.add(mode);
              }

              for (const group of stationGroups.values()) {
                updateGroupMarker(group);
              }

              console.log(`Stations loaded (grouped): groups=${stationGroups.size}, bad=${bad}, rows=${rows.length}`);
              resolve();
            } catch (e) {
              reject(e);
            }
          },
          error: (err) => reject(err)
        });
      });
    }

    async function loadBoundaryGeoJSON() {
      const resp = await fetch(boundaryUrl, { cache: "no-store" });
      if (!resp.ok) throw new Error(`Boundary fetch failed: ${resp.status} ${resp.statusText}`);
      const geo = await resp.json();

      if (ltwAreaLayer) { map.removeLayer(ltwAreaLayer); ltwAreaLayer = null; }
      if (tfAreaLayer)  { map.removeLayer(tfAreaLayer);  tfAreaLayer = null; }

      const feats = (geo && geo.features) ? geo.features : [];
      const ltwFeats = [];
      const tfFeats = [];

      for (const f of feats) {
        const props = f.properties || {};
        const tag = String(props.area || props.remit || "").toLowerCase();
        if (tag === "ltw") ltwFeats.push(f);
        if (tag === "tf" || tag === "gb_rest" || tag === "transport_focus") tfFeats.push(f);
      }

      if (!ltwFeats.length && !tfFeats.length) {
        throw new Error(`Boundary file loaded, but no features were tagged as "ltw"/"tf".`);
      }

      // interactive=false so polygons do NOT intercept station clicks
      if (ltwFeats.length) {
        ltwAreaLayer = L.geoJSON(
          { type: "FeatureCollection", features: ltwFeats },
          {
            interactive: false,
            style: {
              color: "#0b7a3b",
              weight: 3,
              opacity: 1,
              fillColor: "#0b7a3b",
              fillOpacity: 0.12
            }
          }
        );
      }

      if (tfFeats.length) {
        // Fill-only to avoid red outlines (e.g. Thames)
        tfAreaLayer = L.geoJSON(
          { type: "FeatureCollection", features: tfFeats },
          {
            interactive: false,
            style: {
              color: "transparent",
              weight: 0,
              opacity: 0,
              fillColor: "#b2182b",
              fillOpacity: 0.09
            }
          }
        );
      }

      applyLayerToggles();
    }

    function doSearch() {
      const qRaw = document.getElementById("txtSearch").value;
      const q = keyify(qRaw);
      if (!q) return;

      let hit = allGroupMarkers.find(m => m.nameKey === q);
      if (!hit) hit = allGroupMarkers.find(m => m.nameKey.includes(q));

      if (!hit) return alert(`No match found for: ${qRaw}`);

      // Ensure the relevant station layer is visible
      if (hit.remit === REMIT_LTW) document.getElementById("chkLtwStations").checked = true;
      else document.getElementById("chkTfStations").checked = true;

      applyLayerToggles();
      map.setView([hit.lat, hit.lon], 14, { animate: true });
      hit.marker.openPopup();
    }

    // --- Collapsible toggles (chevron) ---
    const togglesWrap = document.getElementById("togglesWrap");
    const btnChevron = document.getElementById("btnChevron");

    function setTogglesCollapsed(collapsed) {
      if (collapsed) togglesWrap.classList.add("collapsed");
      else togglesWrap.classList.remove("collapsed");
      btnChevron.setAttribute("aria-expanded", collapsed ? "false" : "true");
    }

    function isMobile() {
      return window.matchMedia && window.matchMedia("(max-width: 520px)").matches;
    }

    btnChevron.addEventListener("click", () => {
      const currentlyCollapsed = togglesWrap.classList.contains("collapsed");
      setTogglesCollapsed(!currentlyCollapsed);
    });

    // If the viewport changes (rotate phone, resize window), keep behaviour sensible:
    window.addEventListener("resize", () => {
      // On desktop, prefer expanded; on mobile, prefer collapsed (but don't fight user constantly)
      // Only auto-toggle if user hasn't interacted yet.
      // (Simple approach: do nothing here; uncomment below if you WANT auto behaviour.)
    });

    // UI wiring
    document.getElementById("chkLtwArea").addEventListener("change", applyLayerToggles);
    document.getElementById("chkLtwStations").addEventListener("change", applyLayerToggles);
    document.getElementById("chkTfArea").addEventListener("change", applyLayerToggles);
    document.getElementById("chkTfStations").addEventListener("change", applyLayerToggles);

    document.getElementById("btnSearch").addEventListener("click", doSearch);
    document.getElementById("txtSearch").addEventListener("keydown", (e) => {
      if (e.key === "Enter") doSearch();
    });

    // Init
    (async function init() {
      try {
        // Default: collapse toggles on mobile, expand on desktop
        setTogglesCollapsed(isMobile());

        await loadStationsFromCSV();
        applyLayerToggles();
        await loadBoundaryGeoJSON();
      } catch (e) {
        console.error(e);
        alert("Map data failed to load. Please refresh and try again.");
      }
    })();
  </script>
</body>
</html>