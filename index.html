<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>London TravelWatch Area Map</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .panel {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1000;
      width: 360px;
      max-width: calc(100vw - 24px);
      background: rgba(255,255,255,0.97);
      border-radius: 12px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.16);
      padding: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .panel h3 { margin: 0 0 10px 0; font-size: 18px; line-height: 1.2; }

    .row { display: flex; gap: 10px; align-items: center; }
    .row + .row { margin-top: 8px; }
    label { display: flex; align-items: center; gap: 10px; font-size: 15px; }
    input[type="checkbox"] { transform: scale(1.1); }

    .section { margin-top: 14px; border-top: 1px solid rgba(0,0,0,0.08); padding-top: 12px; }

    .search label { font-weight: 700; margin-bottom: 8px; display: block; font-size: 16px; }
    .search .row { align-items: stretch; }
    .search input[type="text"]{
      flex: 1;
      padding: 10px 12px;
      border: 1px solid rgba(0,0,0,0.22);
      border-radius: 10px;
      font-size: 15px;
      outline: none;
    }
    .btn {
      padding: 10px 12px;
      border: 0;
      border-radius: 10px;
      font-size: 15px;
      cursor: pointer;
      background: #2b2b2b;
      color: #fff;
      white-space: nowrap;
    }
    .hint { margin-top: 8px; font-size: 12px; color: rgba(0,0,0,0.68); line-height: 1.35; }

    /* Separate floating key (bottom-right) */
    .map-key {
      background: rgba(255,255,255,0.95);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.16);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 13px;
      line-height: 1.25;
    }
    .map-key .title {
      font-weight: 700;
      margin: 0 0 8px 0;
      font-size: 13px;
    }
    .map-key .legend {
      display: grid;
      grid-template-columns: 14px 1fr;
      gap: 8px 10px;
      align-items: center;
    }
    .map-key .swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.25);
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <h3>London TravelWatch Area Map</h3>

    <!-- Toggles: LTW first (area then stations), then TF (area then stations) -->
    <!-- Stations OFF by default -->
    <div class="row">
      <label><input id="chkLtwArea" type="checkbox" checked> London TravelWatch area</label>
    </div>
    <div class="row">
      <label><input id="chkLtwStations" type="checkbox"> London TravelWatch stations</label>
    </div>
    <div class="row">
      <label><input id="chkTfArea" type="checkbox"> Transport Focus area</label>
    </div>
    <div class="row">
      <label><input id="chkTfStations" type="checkbox"> Transport Focus stations</label>
    </div>

    <div class="section search">
      <label for="txtSearch">Search station…</label>
      <div class="row">
        <input id="txtSearch" type="text" placeholder="e.g. Orpington" />
        <button id="btnSearch" class="btn" type="button">Go</button>
      </div>
      <div class="hint">
        Searches station name (case-insensitive), zooms, and opens the popup.
      </div>
    </div>
  </div>

  <script>
    // Files (kept internal; not shown in UI)
    const CSV_FILE = "correct_ltw_list.csv";
    const BOUNDARY_FILE = "ltw_remit_boundary.geojson";

    const REMIT_LTW = "London TravelWatch";
    const REMIT_TF  = "Transport Focus";

    // ✅ GitHub fix: resolve relative to the *folder* containing this page
    // Works for:
    // - http://localhost:8000/
    // - https://user.github.io/repo/
    // - https://user.github.io/repo/index.html
    const baseUrl = new URL(".", window.location.href);
    const csvUrl = new URL(CSV_FILE, baseUrl).toString();
    const boundaryUrl = new URL(BOUNDARY_FILE, baseUrl).toString();

    const toBool = (v) => String(v).trim().toLowerCase() === "true" || v === true;
    const keyify = (s) => String(s || "").trim().toLowerCase();

    // Map
    const map = L.map("map", { preferCanvas: true }).setView([51.5074, -0.1278], 9);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Floating Key (bottom-right) — light green, dark green, light red, dark red
    const keyControl = L.control({ position: "bottomright" });
    keyControl.onAdd = function () {
      const div = L.DomUtil.create("div", "map-key");
      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);

      div.innerHTML = `
        <div class="title">Key</div>
        <div class="legend">
          <div class="swatch" style="background:#0b7a3b; opacity:0.22;"></div>
          <div>London TravelWatch area</div>

          <div class="swatch" style="background:#0b7a3b;"></div>
          <div>London TravelWatch station</div>

          <div class="swatch" style="background:#b2182b; opacity:0.22;"></div>
          <div>Transport Focus area</div>

          <div class="swatch" style="background:#b2182b;"></div>
          <div>Transport Focus station</div>
        </div>
      `;
      return div;
    };
    keyControl.addTo(map);

    // Layers (stations OFF by default)
    const ltwStationsLayer = L.layerGroup();
    const tfStationsLayer  = L.layerGroup();
    let ltwAreaLayer = null;
    let tfAreaLayer  = null;

    // Search index
    const allMarkers = []; // { nameKey, name, marker, lat, lon, remit }

    function circleStyle(remit) {
      return remit === REMIT_LTW
        ? { radius: 4, weight: 1, opacity: 1.0, fillOpacity: 0.85 }
        : { radius: 4, weight: 1, opacity: 0.9, fillOpacity: 0.65 };
    }

    function circleColors(remit) {
      return remit === REMIT_LTW
        ? { color: "#0b7a3b", fillColor: "#0b7a3b" }
        : { color: "#b2182b", fillColor: "#b2182b" };
    }

    function applyLayerToggles() {
      const showLtwArea     = document.getElementById("chkLtwArea").checked;
      const showLtwStations = document.getElementById("chkLtwStations").checked;
      const showTfArea      = document.getElementById("chkTfArea").checked;
      const showTfStations  = document.getElementById("chkTfStations").checked;

      if (ltwAreaLayer) { if (showLtwArea) map.addLayer(ltwAreaLayer); else map.removeLayer(ltwAreaLayer); }
      if (tfAreaLayer)  { if (showTfArea)  map.addLayer(tfAreaLayer);  else map.removeLayer(tfAreaLayer); }

      if (showLtwStations) map.addLayer(ltwStationsLayer); else map.removeLayer(ltwStationsLayer);
      if (showTfStations)  map.addLayer(tfStationsLayer);  else map.removeLayer(tfStationsLayer);
    }

    async function loadStationsFromCSV() {
      return new Promise((resolve, reject) => {
        Papa.parse(csvUrl, {
          download: true,
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              if (results.errors && results.errors.length) {
                console.warn("PapaParse errors:", results.errors);
              }

              const rows = results.data || [];
              let ltw = 0, tf = 0, bad = 0;

              for (const r of rows) {
                const lat = r.latitude;
                const lon = r.longitude;

                if (typeof lat !== "number" || typeof lon !== "number" || !isFinite(lat) || !isFinite(lon)) {
                  bad++;
                  continue;
                }

                const remit = toBool(r.in_ltw_area) ? REMIT_LTW : REMIT_TF;
                const name = r.name || "(no name)";

                const marker = L.circleMarker([lat, lon], {
                  ...circleStyle(remit),
                  ...circleColors(remit)
                }).bindPopup(
                  `<b>${name}</b><br>` +
                  `Remit: ${remit}<br>` +
                  `Lat/Lon: ${lat.toFixed(6)}, ${lon.toFixed(6)}`
                );

                // Optional but helpful: ensure click always opens popup
                marker.on("click", () => marker.openPopup());

                allMarkers.push({ nameKey: keyify(name), name, marker, lat, lon, remit });

                if (remit === REMIT_LTW) {
                  ltw++;
                  marker.addTo(ltwStationsLayer);
                } else {
                  tf++;
                  marker.addTo(tfStationsLayer);
                }
              }

              console.log(`Stations loaded: LTW=${ltw}, TF=${tf}, bad=${bad}, totalRows=${rows.length}`);
              resolve();
            } catch (e) {
              reject(e);
            }
          },
          error: (err) => reject(err)
        });
      });
    }

    async function loadBoundaryGeoJSON() {
      const resp = await fetch(boundaryUrl, { cache: "no-store" });
      if (!resp.ok) throw new Error(`Boundary fetch failed: ${resp.status} ${resp.statusText}`);

      // ✅ GitHub fix: if someone accidentally pasted Python into the .geojson,
      // resp.json() will throw. This makes it easier to diagnose in console.
      let geo;
      const text = await resp.text();
      try {
        geo = JSON.parse(text);
      } catch (e) {
        console.error("Boundary file is not valid JSON. First 200 chars:", text.slice(0, 200));
        throw new Error("Boundary file is not valid JSON.");
      }

      if (ltwAreaLayer) { map.removeLayer(ltwAreaLayer); ltwAreaLayer = null; }
      if (tfAreaLayer)  { map.removeLayer(tfAreaLayer);  tfAreaLayer = null; }

      const feats = (geo && geo.features) ? geo.features : [];
      const ltwFeats = [];
      const tfFeats = [];

      for (const f of feats) {
        const props = f.properties || {};
        const tag = String(props.area || props.remit || "").toLowerCase();
        if (tag === "ltw") ltwFeats.push(f);
        if (tag === "tf" || tag === "gb_rest" || tag === "transport_focus") tfFeats.push(f);
      }

      if (!ltwFeats.length && !tfFeats.length) {
        throw new Error(`Boundary file loaded, but no features were tagged (expected "ltw" and "tf").`);
      }

      // IMPORTANT: interactive=false so polygons do NOT intercept station clicks
      if (ltwFeats.length) {
        ltwAreaLayer = L.geoJSON(
          { type: "FeatureCollection", features: ltwFeats },
          {
            interactive: false,
            style: {
              color: "#0b7a3b",
              weight: 3,
              opacity: 1,
              fillColor: "#0b7a3b",
              fillOpacity: 0.12
            }
          }
        );
      }

      if (tfFeats.length) {
        // Fill-only to avoid red outlines on rivers/coastlines (e.g. Thames)
        tfAreaLayer = L.geoJSON(
          { type: "FeatureCollection", features: tfFeats },
          {
            interactive: false,
            style: {
              color: "transparent",
              weight: 0,
              opacity: 0,
              fillColor: "#b2182b",
              fillOpacity: 0.09
            }
          }
        );
      }

      applyLayerToggles();
    }

    function doSearch() {
      const qRaw = document.getElementById("txtSearch").value;
      const q = keyify(qRaw);
      if (!q) return;

      let hit = allMarkers.find(m => m.nameKey === q);
      if (!hit) hit = allMarkers.find(m => m.nameKey.includes(q));

      if (!hit) return alert(`No match found for: ${qRaw}`);

      // Ensure the relevant station layer is visible
      if (hit.remit === REMIT_LTW) document.getElementById("chkLtwStations").checked = true;
      else document.getElementById("chkTfStations").checked = true;

      applyLayerToggles();
      map.setView([hit.lat, hit.lon], 14, { animate: true });
      hit.marker.openPopup();
    }

    // UI wiring
    document.getElementById("chkLtwArea").addEventListener("change", applyLayerToggles);
    document.getElementById("chkLtwStations").addEventListener("change", applyLayerToggles);
    document.getElementById("chkTfArea").addEventListener("change", applyLayerToggles);
    document.getElementById("chkTfStations").addEventListener("change", applyLayerToggles);

    document.getElementById("btnSearch").addEventListener("click", doSearch);
    document.getElementById("txtSearch").addEventListener("keydown", (e) => {
      if (e.key === "Enter") doSearch();
    });

    // Init
    (async function init() {
      try {
        await loadStationsFromCSV();
        applyLayerToggles();
        await loadBoundaryGeoJSON();
      } catch (e) {
        console.error(e);

        // Clean, non-debug UI message (no black box)
        alert("Map data failed to load. Please refresh and try again.");
      }
    })();
  </script>
</body>
</html>